# Arquitetura do Sistema - Geolocation

## ?? Índice

- [Visão Geral](#visão-geral)
- [Arquitetura de Alto Nível](#arquitetura-de-alto-nível)
- [Componentes Backend](#componentes-backend)
- [Componentes Frontend](#componentes-frontend)
- [Banco de Dados](#banco-de-dados)
- [Infraestrutura Azure](#infraestrutura-azure)
- [Segurança](#segurança)
- [Performance e Escalabilidade](#performance-e-escalabilidade)
- [Monitoramento](#monitoramento)
- [Decisões Arquiteturais](#decisões-arquiteturais)

---

## ?? Visão Geral

O **Geolocation** é um sistema de processamento e análise de documentos fiscais eletrônicos (NF-e/CT-e) com capacidades de geocodificação e cálculo de rotas.

### Objetivo

Processar arquivos XML de Notas Fiscais Eletrônicas e Conhecimentos de Transporte, extrair informações geográficas, geocodificar endereços e fornecer análises visuais através de uma interface web.

### Princípios

- **Performance**: Rust no backend para processamento rápido
- **Confiabilidade**: Type-safety e error handling robusto
- **Escalabilidade**: Arquitetura stateless pronta para cloud
- **Observabilidade**: Logging, tracing e métricas em todos os níveis
- **Segurança**: Secrets gerenciados, HTTPS, autenticação via Azure

---

## ??? Arquitetura de Alto Nível

```
???????????????????????????????????????????????????????????????
?    FRONTEND     ?
?  ??????????????  ????????????????  ???????????????????     ?
?  ?   React    ?  ?  TailwindCSS ?  ?  Zustand State  ?     ?
?  ?   + Vite   ?  ?    + Lucide  ?  ?    Management   ?     ?
?  ??????????????  ????????????????  ???????????????????     ?
?    ?              ?
?        ? HTTP/REST (Axios)          ?
? ?             ?
????????????????????????????????????????????????????????????????
     ?
????????????????????????????????????????????????????????????????
?        ?          BACKEND (Rust)           ?
?  ????????????????????????????????????????????????????????   ?
?  ?       Axum Web Framework (Async)    ?   ?
?  ????????????????????????????????????????????????????????   ?
?  ?  ??????????????  ???????????????  ????????????????  ?   ?
?  ?  ?    API?  ?   Upload    ?  ?   Search     ?  ?   ?
?  ?  ?  Endpoints ?  ?   Handler   ?  ?  API    ?  ?   ?
?  ?  ??????????????  ???????????????  ????????????????  ?   ?
?  ????????????????????????????????????????????????????????   ?
?  ?  ????????????????????  ????????????????????????????  ?   ?
?  ?  ?   XML Parser     ?  ?   Geocoding Service     ?  ?   ?
?  ?  ?  (quick-xml)?  ?  (Google Maps API)      ?  ?   ?
?  ?  ????????????????????  ????????????????????????????  ?   ?
?  ????????????????????????????????????????????????????????   ?
?  ?  ????????????????????????????????????????????????  ?   ?
?  ?  ?  Database Layer  ?  ?   Observability          ?  ?   ?
?  ??    (SQLx)        ?  ?  (Tracing/Prometheus)    ?  ?   ?
?  ?  ????????????????????  ????????????????????????????  ?   ?
?  ????????????????????????????????????????????????????????   ?
?        ?    ?
????????????????????????????????????????????????????????????????
         ?
         ??????????????????????????????????????????????????????
         ?   ?              ?    ?
???????????????  ????????????????  ???????????????  ??????????????
?  PostgreSQL ?  ? Google Maps  ?  ? Application ?  ?    Azure ?
?  Database   ?  ?     API      ?  ?  Insights   ?  ?  Key Vault ?
???????????????  ????????????????  ???????????????  ??????????????
```

---

## ?? Componentes Backend

### Estrutura de Diretórios

```
src/
??? lib.rs          # Biblioteca principal, exports públicos
??? main.rs     # CLI principal para processamento batch
??? server.rs  # Servidor web (Axum)
??? error.rs               # Tipos de erro customizados
??? google_maps_api.rs # Cliente Google Maps
??? search_api.rs          # Lógica de busca/consulta
??? wasm.rs      # Bindings WebAssembly
```

### Componentes Principais

#### 1. **Servidor Web (server.rs)**

```rust
// Stack de tecnologias
- Axum 0.7     // Web framework assíncrono
- Tower  // Middleware (CORS, logging, etc)
- Tower-HTTP        // File serving, CORS
- Tokio          // Runtime async
- Serde JSON        // Serialização/deserialização
```

**Responsabilidades:**
- Gerenciar rotas HTTP (GET, POST, etc)
- Upload de arquivos XML (multipart/form-data)
- Servir frontend estático
- Health checks
- CORS para requests cross-origin

**Endpoints Principais:**

```
GET  /# Frontend (SPA)
GET  /api/health          # Health check
POST /api/upload       # Upload XML de NF-e/CT-e
GET  /api/documents        # Listar documentos processados
GET  /api/documents/:id   # Detalhes de documento
POST /api/geocode            # Geocodificar endereço
POST /api/route           # Calcular rota
GET  /api/search?q=...       # Buscar documentos
```

#### 2. **XML Parser**

```rust
// Tecnologias
- quick-xml          // Parser XML de alta performance
- serde-xml-rs   // Deserialização XML ? structs Rust
- encoding_rs        // Suporte a encodings (ISO-8859-1, UTF-8)
```

**Processo de Parsing:**

```
????????????????
?  Arquivo XML ?
????????????????
       ?
       ?
??????????????????????
?  Detect Encoding   ?  ? Detecta UTF-8, ISO-8859-1, etc
??????????????????????
     ?
   ?
??????????????????????
?  Parse XML ? Serde ?  ? quick-xml + serde-xml-rs
??????????????????????
      ?
         ?
??????????????????????
?  Validate Schema   ?  ? Valida estrutura NF-e/CT-e
??????????????????????
  ?
         ?
??????????????????????
?  Extract Data    ?  ? Extrai emitente, destinatário, itens
??????????????????????
       ?
     ?
??????????????????????
?  Struct Rust       ?  ? NfeDocument / CteDocument
??????????????????????
```

#### 3. **Geocoding Service (google_maps_api.rs)**

```rust
// Cliente HTTP
- reqwest         // HTTP client assíncrono
- serde_json // Serialização JSON
```

**Funcionalidades:**

- **Geocoding**: Endereço ? (Latitude, Longitude)
- **Reverse Geocoding**: (Lat, Lon) ? Endereço formatado
- **Autocomplete**: Sugestões de endereços
- **Directions API**: Cálculo de rotas otimizadas
- **Distance Matrix**: Distâncias entre múltiplos pontos

**Cache Strategy:**

```rust
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;

struct GeocodingCache {
    cache: Arc<RwLock<HashMap<String, CachedResult>>>,
    ttl: Duration,
}

// LRU cache com TTL de 1 hora
// Reduz chamadas à API do Google Maps
```

#### 4. **Database Layer (SQLx)**

```rust
// ORM e Migrations
- SQLx     // Compile-time verified queries
- Tokio Runtime      // Async pool de conexões
```

**Características:**

- **Type-safe**: Queries verificadas em tempo de compilação
- **Async**: Pool de conexões assíncronas
- **Multi-database**: SQLite (dev), PostgreSQL (prod), MongoDB (opcional)
- **Migrations**: Versionamento de schema SQL

**Schema Principal:**

```sql
-- Documentos fiscais
CREATE TABLE documents (
    id UUID PRIMARY KEY,
    document_type VARCHAR(10) NOT NULL,  -- 'NFE' ou 'CTE'
    xml_content TEXT NOT NULL,
    issuer_name VARCHAR(255),
    issuer_cnpj VARCHAR(14),
    recipient_name VARCHAR(255),
    recipient_cnpj VARCHAR(14),
 issue_date TIMESTAMP,
  total_value DECIMAL(15,2),
    created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- Geocodificação (cache persistente)
CREATE TABLE geocoded_addresses (
    id UUID PRIMARY KEY,
    address_raw TEXT NOT NULL,
    address_formatted TEXT,
    latitude DECIMAL(10,8),
    longitude DECIMAL(11,8),
    confidence_score DECIMAL(3,2),
    geocoded_at TIMESTAMP DEFAULT NOW()
);

-- Índices para performance
CREATE INDEX idx_documents_type ON documents(document_type);
CREATE INDEX idx_documents_issuer ON documents(issuer_cnpj);
CREATE INDEX idx_documents_date ON documents(issue_date DESC);
CREATE UNIQUE INDEX idx_geocoded_address ON geocoded_addresses(address_raw);
```

#### 5. **Error Handling (error.rs)**

```rust
use thiserror::Error;

#[derive(Error, Debug)]
pub enum Error {
#[error("Erro ao parsear XML: {0}")]
    XmlParseError(String),
    
    #[error("Banco de dados: {0}")]
    DatabaseError(#[from] sqlx::Error),
    
    #[error("API Google Maps: {0}")]
    GeocodingError(String),
    
    #[error("IO Error: {0}")]
    IoError(#[from] std::io::Error),
    
    #[error("Documento inválido: {0}")]
    ValidationError(String),
}

// Converte para resposta HTTP Axum
impl IntoResponse for Error {
    fn into_response(self) -> Response {
     // Log error, return JSON response
    }
}
```

#### 6. **Observability**

```rust
// Logging
- tracing             // Structured logging
- tracing-subscriber  // Log output formatting
- env_logger       // RUST_LOG env var support

// Metrics
- prometheus      // Métricas Prometheus
```

**Métricas Coletadas:**

- Request duration (histogram)
- Request count by endpoint
- Error rate
- Database query duration
- Geocoding API calls
- Cache hit/miss ratio

---

## ?? Componentes Frontend

### Estrutura

```
frontend/
??? src/
?   ??? components/        # Componentes React reutilizáveis
?   ??? pages/     # Páginas/rotas
?   ??? hooks/     # Custom React hooks
?   ??? store/        # Zustand state management
?   ??? services/          # API clients (Axios)
?   ??? types/  # TypeScript types/interfaces
?   ??? utils/   # Funções utilitárias
?   ??? App.tsx            # Root component
?   ??? main.tsx       # Entry point
??? public/       # Assets estáticos
??? package.json
```

### Stack Tecnológico

```json
{
  "framework": "React 18",
  "build": "Vite 5",
  "language": "TypeScript 5",
  "styling": "TailwindCSS 3",
  "state": "Zustand 4",
  "http": "Axios 1",
  "routing": "React Router 6",
  "charts": "Recharts 2",
  "icons": "Lucide React",
  "notifications": "React Hot Toast"
}
```

### Componentes Principais

#### 1. **Upload Component**

```typescript
// src/components/FileUploader.tsx
import { useDropzone } from 'react-dropzone';

export const FileUploader = () => {
  const onDrop = async (files: File[]) => {
    const formData = new FormData();
    formData.append('file', files[0]);
    
    await api.uploadXML(formData);
    toast.success('Arquivo processado!');
  };

  const { getRootProps, getInputProps } = useDropzone({
    onDrop,
    accept: { 'text/xml': ['.xml'] },
    maxSize: 10 * 1024 * 1024  // 10MB
  });

  return <div {...getRootProps()}>...</div>;
};
```

#### 2. **State Management (Zustand)**

```typescript
// src/store/documentsStore.ts
import create from 'zustand';

interface DocumentsState {
  documents: Document[];
loading: boolean;
  fetchDocuments: () => Promise<void>;
  addDocument: (doc: Document) => void;
}

export const useDocumentsStore = create<DocumentsState>((set) => ({
  documents: [],
  loading: false,
  fetchDocuments: async () => {
    set({ loading: true });
    const docs = await api.getDocuments();
    set({ documents: docs, loading: false });
  },
  addDocument: (doc) => set((state) => ({ 
    documents: [...state.documents, doc] 
  })),
}));
```

#### 3. **API Client (Axios)**

```typescript
// src/services/api.ts
import axios from 'axios';

const api = axios.create({
  baseURL: import.meta.env.VITE_API_URL || '/api',
  timeout: 30000,
headers: {
    'Content-Type': 'application/json',
  },
});

// Interceptors
api.interceptors.response.use(
  (response) => response,
  (error) => {
    toast.error(error.response?.data?.message || 'Erro na requisição');
    return Promise.reject(error);
  }
);

export const uploadXML = (formData: FormData) => 
  api.post('/upload', formData, {
    headers: { 'Content-Type': 'multipart/form-data' }
  });

export const getDocuments = () => 
  api.get<Document[]>('/documents');

export const geocodeAddress = (address: string) => 
  api.post<GeocodeResult>('/geocode', { address });
```

---

## ??? Banco de Dados

### Multi-Database Support

```rust
// Configuração via DATABASE_URL env var

// Development (SQLite)
DATABASE_URL=sqlite:///app/data/geolocation.db

// Production (PostgreSQL)
DATABASE_URL=postgresql://user:pass@host:5432/geolocation

// Alternative (MongoDB)
DATABASE_URL=mongodb://user:pass@host:27017/geolocation
```

### Migrations

```bash
# SQLx migrations
migrations/
??? 001_create_documents.sql
??? 002_create_geocoded_addresses.sql
??? 003_add_indexes.sql
??? 004_add_full_text_search.sql

# Rodar migrations
sqlx migrate run
```

### Query Examples

```rust
// Type-safe query com SQLx
let documents = sqlx::query_as::<_, Document>(
    "SELECT * FROM documents 
     WHERE document_type = $1 
     AND issue_date >= $2 
ORDER BY issue_date DESC 
     LIMIT $3"
)
.bind("NFE")
.bind(start_date)
.bind(limit)
.fetch_all(&pool)
.await?;

// Prepared statement compilado em build time!
// Erros de SQL detectados antes de executar
```

---

## ?? Infraestrutura Azure

### Recursos Provisionados

```
Resource Group: rg-geolocation
??? Container Registry (ACR)
?   ??? geodev01acr01.azurecr.io
?  ??? geolocation:latest
?
??? App Service Plan
?   ??? geodev01asp01 (Linux, S1 Standard)
?
??? Web App (Container)
?   ??? geodev01app01.azurewebsites.net
?  ??? Runtime: Docker
?     ??? Image: ACR/geolocation:latest
?    ??? Managed Identity: System-assigned
?       ??? Settings:
?           ??? WEBSITES_PORT=8080
?           ??? RUST_LOG=info
?        ??? DATABASE_URL (from Key Vault)
?
??? Log Analytics Workspace
?   ??? geodev01law01
?       ??? Retention: 30 days
?       ??? Logs: HTTP, Console, App
?
??? Application Insights
?   ??? geodev01ai01
?       ??? Metrics: Requests, Exceptions, Dependencies
?    ??? Live Metrics Stream
?
??? Key Vault (opcional)
?   ??? geodev01kv01
?       ??? Secrets:
?       ?   ??? database-url
?       ?   ??? google-maps-api-key
?       ??? Access: Managed Identity RBAC
?
??? PostgreSQL Flexible Server (opcional)
    ??? geodev01pg01.postgres.database.azure.com
    ??? Version: 16
     ??? SKU: Standard_B2s
        ??? Database: geolocation
```

### Deployment Flow

```
????????????????
?  Git Push    ?
?  to main     ?
????????????????
       ?
       ?
????????????????????????
?  GitHub Actions      ?
?  ??????????????????  ?
?  ? cargo test     ?  ? ? Rust tests
?  ??????????????????  ?
?  ??????????????????  ?
?  ? npm run build  ?  ? ? Frontend build
?  ??????????????????  ?
?  ??????????????????  ?
?  ? docker build   ?  ? ? Container image
?  ???????????????????
????????????????????????
       ?
       ?
????????????????????????
? Azure Bicep Deploy   ?
? ???????????????????? ?
? ? Deploy Infra     ? ?
? ???????????????????? ?
????????????????????????
       ?
       ?
????????????????????????
? Push to ACR    ?
? geodev01acr01        ?
????????????????????????
       ?
       ?
????????????????????????
? Update Web App       ?
? ???????????????????? ?
? ? Pull new image   ? ?
? ? Restart app      ? ?
? ???????????????????? ?
????????????????????????
```

---

## ?? Segurança

### Camadas de Segurança

1. **Network**
   - HTTPS obrigatório (App Service)
   - TLS 1.2 mínimo
   - CORS configurado (origins permitidos)

2. **Authentication/Authorization**
   - Azure Managed Identity (sistema)
   - RBAC no Key Vault
   - ACR Pull role para Web App

3. **Secrets Management**
   - Key Vault para credentials
   - Referências Key Vault no App Service
   - Sem secrets em código/config

4. **Application**
   - Input validation (XML schema)
   - SQL injection protection (prepared statements)
   - File upload validation (tamanho, tipo)
   - Error messages sanitizados

5. **Monitoring**
   - Application Insights (detecção de anomalias)
   - Log Analytics (auditoria)
   - Failed authentication alerts

---

## ? Performance e Escalabilidade

### Otimizações Backend

```rust
// 1. Async/await em tudo I/O
#[tokio::main]
async fn main() {
    // Pool de conexões assíncrono
    let pool = PgPoolOptions::new()
        .max_connections(20)
        .connect(&database_url).await?;
}

// 2. Processamento paralelo
use rayon::prelude::*;

let results: Vec<_> = files.par_iter()
.map(|file| process_xml(file))
    .collect();

// 3. Cache em memória
use moka::future::Cache;

let cache: Cache<String, GeocodeResult> = Cache::builder()
    .max_capacity(10_000)
    .time_to_live(Duration::from_secs(3600))
    .build();
```

### Otimizações Frontend

```typescript
// 1. Code splitting
const DocumentViewer = lazy(() => import('./DocumentViewer'));

// 2. Memoization
const ExpensiveComponent = memo(({ data }) => {
  const processed = useMemo(() => processData(data), [data]);
  return <div>{processed}</div>;
});

// 3. Virtualization (listas grandes)
import { FixedSizeList } from 'react-window';

// 4. Debounce em buscas
const debouncedSearch = useDebounce(searchTerm, 300);
```

### Escalabilidade

- **Horizontal**: Stateless, múltiplas instâncias no App Service
- **Vertical**: Upgrade de SKU conforme demanda
- **Database**: Read replicas, connection pooling
- **Cache**: Redis/Memcached para cache distribuído (futuro)

---

## ?? Monitoramento

### Métricas Chave

```
Application Insights KQL queries:

// Request duration P95
requests
| where timestamp > ago(1h)
| summarize percentile(duration, 95) by bin(timestamp, 1m)

// Error rate
requests
| where timestamp > ago(1h)
| summarize total=count(), errors=countif(success == false)
| extend errorRate = errors * 100.0 / total

// Dependency calls (Google Maps API)
dependencies
| where type == "Http"
| where target contains "googleapis.com"
| summarize count(), avg(duration) by resultCode
```

### Alertas

- Erro rate > 5%
- P95 latency > 2s
- Failed dependencies
- High CPU/Memory usage
- Database connection pool exhaustion

---

## ?? Decisões Arquiteturais

### Por que Rust no Backend?

? **Performance**: 5-10x mais rápido que Python/Node em parsing XML  
? **Memory Safety**: Sem GC, sem race conditions  
? **Concurrency**: Async/await nativo, Tokio runtime eficiente  
? **Type Safety**: Erros detectados em compile-time  
? **Tradeoff**: Curva de aprendizado mais íngreme

### Por que Axum?

? Baseado em Tower (middleware maduro)  
? Performance similar ao Actix, mais simples  
? Integração natural com Tokio  
? Type-safe extractors

### Por que SQLx vs Diesel?

? Compile-time verified queries  
? Async nativo (Diesel ainda experimental)  
? Suporte multi-database built-in  
? Menos features de ORM completo

### Por que Azure App Service vs AKS?

? Simplicidade: PaaS gerenciado  
? Custo: Mais barato para workload pequeno/médio  
? Integração: Managed Identity, Key Vault, App Insights  
? Limitação: Menos controle sobre infra

---

## ?? Evolução Futura

### Roadmap Técnico

1. **Curto Prazo** (1-3 meses)
   - [ ] Autenticação/autorização (OAuth2/OIDC)
   - [ ] API de busca full-text (PostgreSQL FTS)
   - [ ] Cache distribuído (Redis)
   - [ ] Rate limiting

2. **Médio Prazo** (3-6 meses)
   - [ ] Processamento em background (queue)
   - [ ] Exportação de relatórios (PDF)
   - [ ] Webhooks para notificações
   - [ ] Multi-tenancy

3. **Longo Prazo** (6+ meses)
   - [ ] Machine Learning (classificação automática)
   - [ ] GraphQL API
   - [ ] Mobile app (React Native)
   - [ ] Migração para AKS (se escala necessitar)

---

**Última Atualização**: 2025-01-11  
**Versão**: 1.0  
**Mantenedor**: Avila DevOps
